# -*- coding: utf-8 -*-
############################################################
#
# Autogenerated by the KBase type compiler -
# any changes made here will be overwritten
#
############################################################

from __future__ import print_function
# the following is a hack to get the baseclient to import whether we're in a
# package or not. This makes pep8 unhappy hence the annotations.
try:
    # baseclient and this client are in a package
    from .baseclient import BaseClient as _BaseClient  # @UnusedImport
except ImportError:
    # no they aren't
    from baseclient import BaseClient as _BaseClient  # @Reimport


class KBParallel(object):

    def __init__(
            self, url=None, timeout=30 * 60, user_id=None,
            password=None, token=None, ignore_authrc=False,
            trust_all_ssl_certificates=False,
            auth_svc='https://ci.kbase.us/services/auth/api/legacy/KBase/Sessions/Login',
            service_ver='release',
            async_job_check_time_ms=100, async_job_check_time_scale_percent=150, 
            async_job_check_max_time_ms=300000):
        if url is None:
            raise ValueError('A url is required')
        self._service_ver = service_ver
        self._client = _BaseClient(
            url, timeout=timeout, user_id=user_id, password=password,
            token=token, ignore_authrc=ignore_authrc,
            trust_all_ssl_certificates=trust_all_ssl_certificates,
            auth_svc=auth_svc,
            async_job_check_time_ms=async_job_check_time_ms,
            async_job_check_time_scale_percent=async_job_check_time_scale_percent,
            async_job_check_max_time_ms=async_job_check_max_time_ms)

    def run_batch(self, params, context=None):
        """
        Run many tasks in parallel, either locally or remotely.
        :param params: instance of type "RunBatchParams" (* Run a set of
           multiple batch jobs, either locally or remotely. If run remotely,
           they will be * started using NarrativeJobService#run_job. If run
           locally, the job will be started using the * callback server. * *
           Required arguments: *   tasks - a list of task objects to be run
           in batch (see the Task type). * Optional arguments: *   runner -
           one of 'local_serial', 'local_parallel', or 'parallel': *     
           local_serial - run tasks on the node in serial, ignoring the
           concurrent task limits *      local_parallel - run multiple tasks
           on the node in parallel. Unless you know where your *        job
           will run, you probably don't want to set this higher than 2 *     
           parallel - look at both the local task and njsw task limits and
           operate appropriately. *        Therefore, you could always just
           select this option and tweak the task limits to get *       
           either serial_local or parallel_local behavior. *  
           concurrent_njsw_tasks - how many concurrent tasks to run remotely
           on NJS. This has a *     maximum of 50. *   concurrent_local_tasks
           - how many concurrent tasks to run locally. This has a hard
           maximum *     of 20, but you will only want to set this to about 2
           due to resource limitations. *   max_retries - how many times to
           re-attempt failed jobs. This has a minimum of 1 and *     maximum
           of 5. *   parent_job_id - you can manually pass in a custom job ID
           which will be assigned to NJS *     sub-jobs that are spawned by
           KBParallel. This is useful if you need to track the running *    
           tasks that were started by KBParallel. *   workspace_id - a custom
           workspace ID to assign to new NJS jobs that are spawned by *    
           KBParallel.) -> structure: parameter "tasks" of list of type
           "Task" (* Specifies a task to run by module name, method name,
           version, and parameters. Parameters is * an arbitrary data object
           passed to the function.) -> structure: parameter "function" of
           type "Function" (Specifies a specific KBase module function to
           run) -> structure: parameter "module_name" of String, parameter
           "function_name" of String, parameter "version" of String,
           parameter "params" of unspecified object, parameter "runner" of
           String, parameter "concurrent_local_tasks" of Long, parameter
           "concurrent_njsw_tasks" of Long, parameter "max_retries" of Long,
           parameter "parent_job_id" of String, parameter "workspace_id" of
           Long
        :returns: instance of type "BatchResults" (The list of results will
           be in the same order as the input list of tasks.) -> structure:
           parameter "results" of list of type "TaskResult" -> structure:
           parameter "is_error" of type "boolean" (A boolean - 0 for false, 1
           for true. @range (0, 1)), parameter "result_package" of type
           "ResultPackage" -> structure: parameter "function" of type
           "Function" (Specifies a specific KBase module function to run) ->
           structure: parameter "module_name" of String, parameter
           "function_name" of String, parameter "version" of String,
           parameter "result" of unspecified object, parameter "error" of
           unspecified object, parameter "run_context" of type "RunContext"
           (location = local | njsw job_id = '' | [njsw_job_id] May want to
           add: AWE node ID, client group, total run time, etc) -> structure:
           parameter "location" of String, parameter "job_id" of String
        """
        return self._client.run_job('KBParallel.run_batch',
                                    [params], self._service_ver, context)

    def status(self, context=None):
        return self._client.run_job('KBParallel.status',
                                    [], self._service_ver, context)
